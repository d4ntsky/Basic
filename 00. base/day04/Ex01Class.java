package day04;
// 클래스 컨닝페이퍼
/*
 * 클래스란, 한개의 프로그램으로써
 * 우리가 만드는 프로그램들은 클래스의 집합 즉 작은 프로그램들의 집합이 된다.
 * 
 * 이렇게 작은 프로그램들로 우리가 나누어놨기 때문에, 
 * 우리가 필요하다면 그 작은 프로그램 하나하나를 다시 사용할 수 있다.
 * 
 * 클래스는 필드와 메소드로 나눠진다.
 * 필드   : 클래스의 속성값들
 * 		    예시: TV의 볼륨, 학생의 국어점수 등
 * 메소드: 클래스의 기능
 *        예시: TV의 채널변경하기, scanner.nextInt()
 *        
 * 필드는 우리가 클래스의 변수를 선언하듯 써주면 된다.
 * int id, String name .....
 * 하지만 여기에 우리가 값을 넣지 않는다.
 * 왜냐! 값을 넣는 것은 이 클래스를 불러서 쓰는 더 큰 프로그램을 담당하기 때문이다.
 * 즉 우리는 이 클래스의 속성이 어떻게 생겼는지만 적어주면 된다.
 * 
 * 메소드는 기능으로써 그 프로그램이 어떤 기능이 있는지를 선언하고
 * 어떤 기능이 어떻게 구현되었는지를 적어주게 된다.
 * 메소드는 반드시 ()가 뒤에 붙는다.
 * 
 * 즉 ()가 붙으면 메소드다!
 * 
 * 사실, 우리가 매일매일 많은 메소드들을 만들어왔다!
 * 바로 메인이 메소드이다.
 * public Static void main(String[] args)
 * 
 * 접근 제한자(Access Modifier)
 * 접근 제한자란, 해당 메소드 혹은 해당 필드가
 * 어디서 호출 가능한 지를 정해주는 예약어이다.
 * public - protected - default - private 순으로 단계가 나뉜다.
 * 
 * public    : 외부 클래스든 외부 패키지든 어디서든지 접근 가능하다.
 * protected : 같은 패키지와 상속을 받는 클래스면 접근 가능하다.
 * default   : 같은 패키지면 접근 가능하다. 우리가 아무것도 적어주지 않으면 자동으로 default 접근 제한이 걸린다.
 * private   : 해당 클래스 내부에서만 접근 가능하다.
 * 
 * 예전에는 이 access modifier를 그리 중요하게 여기지 않았지만
 * '캡슐화' 라는 개념 때문에 이제는 모든 필드 그리고 꼭 외부에 공개해야하는 메소드가 아니면 모두다 private으로 적어주게 된다.
 * 
 * '캡슐화' 란 우리 클래스를 하나의 캡슐로 만드는 것이다.
 * 굳이 우리 클래스가 어떤 메소드가 있고 어떤 필드가 있고를 외부에 다 공개하는 게 아니라
 * 정말 외부가 꼭 필요한 것들만 알려주자하는 것이 '캡슐화'이다.
 * 
 * 메소드는 
 * 리턴타입 이름(파라미터) 로 이루어져있다.
 * 리턴타입 : 해당 메소드가 종료될 때 호출된 곳으로 보내줄 데이터의 타입
 * 			만약 해당 메소드가 종료될 때 아무런 데이터도 보내주지 않는다면 void 라고 적어준다.
 * 이름       : 소문자로 시작하는 동사
 * 파라미터 : 이 메소드가 필요로 하는 외부의 데이터를 변수처럼 적어놓는다.
 * 			만약 아무런 외부 데이터가 필요없다면 아무것도 적어주지 않는다.
 * 
 * 이제는 필드가 private 접근 제한자가 달리기 때문에
 * 더이상 외부에서 곧장 접근할수 없다.
 * 대신 메소드를 통해서 값을 넣거나 혹은 값을 불러오거나 해야한다.
 * 이렇게 필드에 값을 넣는 메소드를 setter 메소드라고 하고
 * 필드에 값을 불러오는 메소드를     getter 메소드라고 한다.
 * 
 * setter 메소드 만드는 방법
 * public void set필드명(필드데이터타입 필드이름){
 * 	this.필드이름 = 필드이름;
 * }
 * 
 * getter 메소드 만드는 방법
 * public 필드데이터타입 get필드명(){
 * 	return 필드이름;
 * }
 * 
 * null
 * null이란 stack 영역에 메모리 주소는 부여가 되어있지만
 * heap 영역의 해당 메모리 주소 부분은 초기화가 안 되어서 아무 것도 없는 상태를 
 * null이라고 한다.
 * 
 * null 인 상태에서는 필드 혹은 메소드 호출은 할 수 없다.
 * 
 * 생성자(Constructor)
 * 생성자란 해당 클래스 객체가 만들어질 때
 * 실행되는 메소드로서 필드의 값이나 특정 코드를 실행하게 만들어진다.
 * 
 * 우리가 생성자를 따로 만들지 않더라도
 * 자바는 기본적인 생성자를 제공해준다.
 * 
 * 이 기본 생성자에서는
 * 기본형 데이터타입인 필드는 0 으로 초기화하고
 * 참조형 데이터타입인 필드는 null로 초기화한다.
 * 
 * 필요에 따라선 우리가 직접 생성자를 정의해줄수도 있다.
 * 이때 주의해야할 것은
 * 1. 생성자의 이름은 무조건 클래스의 이름과 같다.
 * 2. 만약 파라미터가 있는 생성자만 선언과 정의하면
 *    더이상 파라미터가 없는 생성자는 호출 할 수 없다.
 *    예시 : Scanner scanner = new Scanner(System.in);
 *    									//(System.in)을 빼면 에러가 난다. (여기서 in은 그 클래스 내에서 읽어온것/파일에서 불러올 수도 있음)
 *    
 *    따라서 파라미터가 있는 생성자와 없는 생성자를 모두 쓰고 싶다면 두개다 만들어줘야 한다!
 * 
 * 파라미터와 필드의 우선순위
 * 메소드 안에서는 파라미터가 우선된다.
 * 즉
 * public Car(String number) {
 * 		number = number;
 * }
 * 라고 적게될 시에는 필드 number에 파라미터 number를 넣는게 아니라
 * 파라미터 number에 파라미터 number를 넣는다는 의미가 된다.
 * 
 * 따라서 명확하게 "필드" number에 파라미터 number를 넣으라고 우리가 지정해주어야 한다.
 * 
 * 필드를 지정할 때에는
 * this. 을 붙여주면 된다.
 * this란 이 메소드를 호출하는 객체 자신을 가르키는 예약어이다.
 * 
 * 파라미터
 * 파라미터는 우리가 메소드에서 부르기 편하라고 적어놓는 이름일 뿐이다.
 * 우리가
 * Car(String number, String type, String color, int price)라고 적고선
 * new Car("소나타", "빨강색", "00가 0000", 12000) 으로 생성자를 호출하더라도
 *         여기는 위에와 달리 순서가 바뀌어 있는 것을 확인 할 수 있는데 (string이나 int) 데이터타입으로 찾는 것이다.
 * 전혀 문제가 될 것이 없다!
 * 
 * java.lang.Object 클래스
 * 자바에서는 객체를 기본적으로 틀을 만들 수 있게
 * java.lang.Object 라는 클래스를 상속해서
 * Object 클래스의 메소드를 모든 클래스가 쓸 수 있게 해놨다.
 * 
 * 하지만 java.lang.Object 클래스의 메소드들은
 * 누구든 쓸 수 있어야 하기 때문에 대단히 두루뭉실하게 구현되어있다.
 * 따라서 우리 클래스의 맞출려면 우리가 "재정의" 해주어야 하다.
 * 
 * 이렇게 상속받은 메소드를 자식 클래스가 재정의하는 것을
 * overriding이라고 한다!
 * 
 * 
 */
// cf) // 한줄짜리 주석 /* 주석
// cf) 패키지 전체를 복사하는 방법?
// cf) 실수로 내용을 지웠을때 이전 편집점으로 돌리는 법은?

public class Ex01Class {
}
