package classData;

public class Java15Exception2 {
	public static void main(String[] args) {
	/* 예외처리란?	
	Java 프로그램을 작성하는 경우, 컴파일 시점에서 오류가 발생하는 경우, 실행 중
	오류가 발생할 수 있다. 컴파일 시점에서 오류가 발생하는 프로그램이 문법적으로
	틀릴 경우, 구문의 사용법을 잘 못 했다든가 변수 이름 설명 오류 등이 있다.
	int n = 10; 
	if (n == 10 { 
		System.out.println ( "10입니다"); 
	} 
	if문 조건식 뒤 ")"가 기술되어 있지 않기 때문이다. 이와 같이 컴파일 시점에서
	오류가 되는 경우는 작성이 잘못되거나 int변수에 String클래스의 객체를 할당하려고
	하는 등 문법적 오류가 있는 경우다. 
	그리고 런타임 오류이다. 실행시 발생하는 오류는 예상치 못한 오류이다. 예를 들어
	사용자가 입력한 값을 숫자로 변환하여 출력하는 프로그램인 경우 숫자가 입력되는 것을
	전제로 프로그램이 작성돼있음에도 불구하고 숫자가 아닌 문자가 입력된 때에 실행 시 
	오류가 발생한다.
	그 밖에도 파일을 열고 뭔가 쓰기를 하려고했지만, 그 파일이 없는 경우 등에도 런타임
	오류가 발생한다. 파일이 실제로 있는지 컴파일 시점에서 판단할 수 없다. 파일을 여는
	프로그램을 작성하는 방법이 잘 못되지 않으면 컴파일은 성공하지만 실제로 실행해보면,
	파일이 발견되지 않아서 오류가 발생한다. 다음 예는 실행시 에러가 난다.
	int n [] = {18, 29, 36}; 
		System.out.println ( "시작합니다"); 
		for (int i = 0; i <4; i++) { 
			System.out.println (n [i]); 
		} 
	System.out.println ( "종료되었습니다"); 
	이번 프로그램은 배열의 요소가 3개 밖에 없는데 네번째 요소를 참조하려고 했기때문에
	오류가 발생한다. Java에선 이러한 프로그램의 실행 중 오류가 발생하는 것을 예외가
	발생했다고 한다.
	방금 전의 샘플의 실행결과를 보다시피 예외가 발생하면 프로그램은 거기서 종료되고 이후
	프로그램을 실행하지 않는다. 갑자기 프로그램이 종료되어버리면 원인을 알 수 없게 될
	수도 있고 프로그램을 실행하는 사람에게 오류 메시지를 표시하지 않을 수도 있다.
	거기서 예외가 발생했을 때 단순히 프로그램을 종료시키는 것이 아니라 지정된 동작을
	시키기 위한 구조가 준비되어 있다. 그 것이 예외 처리라는 것이다. 예외가 발생하는 것은
	다양한 원인이 있다. 예외처리에서 예외가 일어난 원인마다 다르게 처리할 수 있는 구조가
	준비되어있다.
	*/	
		
	/*	try문
	예외 처리를 할 try문을 사용하고 형식은 다음과 같다.
	try{
		예외가 발생하고 있는지 테스트할 문장1;
		예외가 발생하고 있는지 테스트할 문장2;
		...
	}
	catch(예외클래스1 변수명1) {
		예외 클래스 1의 예외가 발생했을 때 할 문장;
		...
	}
	catch(예외클래스2 변수명2) {
		예외 클래스 2의 예외가 발생했을 때 할 문장;
		...
	}
	먼저 프로그램에서 예외가 발생했는 지 여부를 조사하는 대상의 문장을 try 하고 "{"부터
	"}"까지 블록 내에 기술한다. 그리고 예외가 발생헀을 때 수행할 작업을 catch 후에 {}
	블록 내에 기술한다.
	처리의 흐름은 try블록 내에서 예외가 발생하면 처리는 중단된다. 그리고 처리는 catch
	부분으로 이동한다. Java에서는 예외의 종류마다 클래스가 준비돼있다. 예외가 발생하면,
	대응하는 클래스의 객체가 생성되고 객체가 catch에 전달되고있다. 
	전달되어온 예외 클래스의 객체가 catch의 {}에 설명된 예외클래스와 일치하는 경우, 변수
	에 전달되어 예외클래스의 객체가 할당되고, 이후 {} 안의 처리가 실행된다.
	catch 하나의 try 대해 여러가지를 작성할 수 있기 때문에 발생할 수 있는 예외에 여러 
	catch를 장성해도 별도의 작업을 수행하게 할 수 있다. 만약 발생한 예외와 일치하는 catch
	가 없으면 아무 처리도 하지 않는다.
	catch 블록 내에 기술된 처리가 실행되면, try문장 전체의 처리가 종료 try문 다음으로
	처리가 이동한다.
	*/	
	
	/*	실제 프로그램에서 예외 처리 흐름
	실제 프로그램을 예로 들어 확인합니다. 
	int n [] = {18, 29, 36}; 
		System.out.println ( "시작합니다"); 
		for (int i = 0; i <4; i ++) {
			System.out.println (n [i] );
	} 
	System.out.println ( "종료되었습니다"); 
	
	이 프로그램을 대상으로 예외 처리를 설명하려고 합니다. 
 	우선 예외를 처리 할 문장을 try 블록 안에 넣을 필요가 있습니다만, 
	전체 프로그램을 try 문 블록에 넣을 수 있습니다.

	try {
		int n [] = {18, 29, 36}; 
			System.out.println ( "시작합니다"); 
		for (int i = 0; i <4; i ++) { 
			System.out.println (n [i]); 
		} 
		System.out.println ( "종료되었습니다"); 
	} catch (예외 클래스 변수 명) { } 

	이 경우 예외 처리를 종료하고 try 문 다음에 처리가 이동하는 프로그램은 끝이므로 
	프로그램이 종료됩니다.

	다른 방법으로 예외가 발생할 가능성이 있는 문장만 try 문 안에 넣을 수 있습니다.

	int n [] = {18, 29, 36}; 
		System.out.println ( "시작합니다"); 
		for (int i = 0; i <4; i ++) { 
			try { 
				System.out.println (n [i]); 
			} 
			catch (예외 클래스 변수 명) { } 
		} 
	System.out.println ( "종료되었습니다");

	try 블록 내에 어떤 문구를 넣는지는 예외 처리를 어떻게 했는지에 따라 검토 할 필요가
	있습니다. 이번에는 예외가 발생하면 배열 요소의 출력을 종료 "종료되었습니다"라는 메시지가 
	화면에 나타나도록하기 위해 다음과 같이 작성할 수 있습니다.

	int n [] = {18, 29, 36}; 
		System.out.println ( "시작합니다"); 
		try { 
		for (int i = 0; i <4; i ++) { 
			System.out.println (n [i]); 
		} 
	} 
	catch (예외 클래스 변수 명) { } 
		System.out.println ( "종료되었습니다");
	
	다음 예외가 발생했을 때의 처리를 기술합니다. 이번에 발생할 수 있는 
	예외는 "ArrayIndexOutOfBoundsException"예외입니다. 
	이 범위를 초과 배열의 요소를 참조 할 때 발생하는 예외입니다. 
	int n [] = {18, 29, 36}; 
		System.out.println ( "시작합니다"); 
		try { 
		for (int i = 0; i <4; i ++) { 
			System.out.println (n [i]); 
			} 
		} 
		catch (ArrayIndexOutOfBoundsException e) { 
		System.out.println ( "배열의 범위를 초과했습니다"); 
		} 
	System.out.println ( "종료되었습니다");

	try 블록 내에서 예외가 발생했을 경우, 
	그 예외가 ArrayIndexOutOfBoundsException이라고 catch 블록의 처리가
	실행됩니다. 이번에는 오류 메시지가 화면에 표시됩니다만 	전달된 예외 클래스의 객체를
	이용할 수 있습니다. 
	
	예외가 발생해도 오류 메시지가 표시되지 않고 catch 블록에서 기술 한 처리가 실행되고 
	있습니다. 	그리고 프로그램도 중간에 종료하지 않고 try 문 이후의 문장도 실행되는 것을 
	확인할 수 있습니다.
	 */
		
	/*	반드시 수행할 처리에 기술 (try...catch...finally)
	try 블록에서 예외가 발생하면 나머지 처리는 실행되지 않고 catch 블록으로 처리가
	이동하게된다.
	try {
		실행문1;
		실행문2;
		실행문3;
	}
	catch (예외클래스 변수명) {
	 	예외가 발생했을 때 수행할 문장;
	}
	try 블록 안에서 예외가 발생하지 않으면 실행문1, 실행문2, 실행문3 순으로 실행 try
	문 다음으로 처리가 이동한다.
	그에 대한 예를 들어 실행문1, 실행문2 이 실행 여기에서 예외가 발생했을 경우, 실행문3은
	실행되지 않고 catch 블록으로 처리가 이동한다. (그리고 예외의 종류가 catch 거리에
	쓰여진 예외인 경우엔 catch 블록에서 처리가 수행된다.)
	이와 같이 try 블록 안에 처리는 실행될지 안될지 가능성이 모두 존재하지만, try문을 
	종료하기 전에 실행시키고 싶은 처리가 있었을 경우엔 finally를 사용하여 작성할 수 있다.
	try { 
		예외가 발생하고 있는지 테스트 문장 1; 
		예외가 발생하고 있는지 테스트 문장 2; 
		... 
	} 
	catch (예외 클래스 1 변수 명 1) { 
		예외 클래스 1의 예외가 발생했을 때 할 문장; 
		... 
	} 
	catch (예외 클래스 2 변수 명 2) { 
		예외 클래스 2 예외가 발생했을 때 할 문장; 
		... 
	} 
	finally { 
		예외가 발생 여부와 관계없이 실행 문; 
		... 
	}
	finally 후에 {...}까지의 블록에 기술된 처리는 try문에서 예외가 발생해도, 하지않아도
	반드시 실행된다. 그러므로 반드시 하고싶은 처리가 있는 경우에는 finally 블록을 포함하여
	블록 내에 기술하도록 한다.
	
	int n [] = {18, 29, 36}; 
		System.out.println ( "시작합니다"); 
	try { 
		for (int i = 0; i <4; i ++) { 
			System.out.println (n [i]); 
		} 
	} 
	catch (ArrayIndexOutOfBoundsException e) { 
		System.out.println ( "배열의 범위를 초과했습니다"); 
	} 
	finally { 
		System.out.println ( "배열의 출력이 종료되었습니다"); 
	} 
	System.out.println ( "종료되었습니다"); 
	이 경우 try 문에서 예외가 발생하거나 하지 않아도
				"배열의 출력이 종료되었습니다" 는 화면에 출력되게 됩니다.

	finally와 try 문 다음에 설명하는 것과의 차이
	또한 반드시 실행되는 처리하는 것이라면 다음과 같이 기입해도 동일한 처리입니다.
	
	int n [] = {18, 29, 36}; 
	System.out.println ( "시작합니다"); 
	try { 
		for (int i = 0; i <4; i ++) { 
			System.out.println (n [i]); 
		} 
	} catch (ArrayIndexOutOfBoundsException e) { 
		System.out.println ( "배열의 범위를 초과했습니다"); 
	} 
	System.out.println ( "배열의 출력이 종료되었습니다"); 
	System.out.println ( "종료되었습니다");
	이 프로그램의 경우에는 동일한 결과가 되지만, 만약 이 프로그램이 메소드에 작성되어있고 catch
	블록에서 return문 등에 의해서 처리가 중간에서 끝나는 경우, try문 다음에 기입된 프로세스는
	실행되지않는다. 하지만 finally 블록을 사용하면 catch블록에서 return문이 실행된 경우도
	반드시 실행된다.
	(단, System.exit(0)에 의해 프로그램을 종료한 경우는 제외)
	*/
	 
	}
}
