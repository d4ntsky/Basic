package day04;
//import day03.Ex16GradeBook01;

// 배열
// 배열이란 똑같은 데이터타입을 묶어서
// 하나의 변수처럼 써주는 것을 배열이라고 한다.
// 배열을 선언할 때에는
// 데이터 타입[] 배열이름 = new 데이터타입[크기];
// 로 선언하고
// 어떤 위치에 접근할 때에는 벼열이름[위치] 로 접근한다.
// 하지만 배열은 더 이상 잘 안 쓰인다.....

public class Ex02Array {
	public static void main(String[] args) {
    //접근   /메소드 /void는 return타입 /main은 메소드 이름 /string 배열 /args는 그 배열에 이름
//main 치고 컨트롤+스페이스+엔터 = 자동완성
		//위의 import day03.Ex16GradeBook01; 를 불러와야지 확인 가능
		//Car c = new Car();
		//c.start();
		//Ex16GradeBook01.main(args);
		
		//크기가 5인 int 배열 arr
		int[] arr = new int[5];
		
		//배열의 위치(=index)는 0부터 크기-1 이다.
		//인덱스는 0보다 작거나 크기보다 크거나 같을 수 없다.
		//만약 인덱스가 잘못 입력되면
		//에러가 뜬다.
		
		//배열이름[인덱스]는 하나의 변수처럼 우리가 사용가능하다
		arr[3] = 100;
		System.out.println(arr[3]);
		
		//배열의 단점
		//1. 크기가 고정되어있다.
		//2. 배열은 2세대부터있던 개념이기 때문에 클래스와 객체에 비친화적이다.
		
		Car[] carArray = new Car[4];
		// 배열은 우리가 new를 쓰더라도 각 인덱스에 대한 생성자 호출이 아닌
		// 배열의 크기만큼의 주소만 초기화한다.
		// 즉, 객체의 배열은 각 인덱스마다 생성자를 호출해줘야 한다!
		for(int i = 0; i < carArray.length; i++) {
			carArray[i] = new Car();
		}
		
		// 또한 어디가 비어있는지 찾기도 까다롭다.
		// 왜냐하면 배열은 크기가 고정되어있기 때문에
		// 우리가 배열 전체를 돌아다니면서 특정 필드가 값이 얼마인지
		// 확인해야지만 그 인덱스가 비어있는지 체크가 가능하다.
		carArray[0].start();
		
		// 한번 우리가 직접 배열이 얼마나 귀찮은지 체험해보고
		// 그럼 배열 대신 무엇을 쓸지도 생각해 봅시다.
	}
}