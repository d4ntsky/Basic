package classData;

public class Java12Cast {
	public static void main(String[] args) {
	/*	형변환
	형변환은 다른 데이터형 간의 연산이 수행될 때 발생
	예를 들어 int변수의 short형의 값을 할당하거나 int형의 값과 long형의 값을 곱하는
	경우다. 이럴 때 하나의 값이 다른 쪽의 값의 데이터형식으로 변환이 이뤄진다.
	이 때 크기가 작은 형태로부터 큰 형태로 변환하는 경우와
	반대로 큰 형태에서 작은 형태로 변환되는 경우의 두 가지가 있다.
	  크기가 작은 형태로부터 큰 형태로 변환
	  크기가 큰  형태에에서 작은 형태로 변환
	여기에서 크기라는 것은 표현할 수 있는 숫자의 크기다.
	예를 들어 long형은 64비트 float형은 32비트이지만 표현할 수 있는 숫자의 크기는
	float형이 크기 때문에 크기로는 float형이 long형보다 커진다.
				double(64bit)
				float(32bit)
				long(64bit)
				int(32bit)
		short(16bit)	char(16bit)
				byte(8bit)
	  int형과 long형을 살펴보면, int를 long형으로 변환하는 경우는 작은 형태로부터
	큰 형태로 변환되고, 반대로 long형을 int형으로 변환하는 경우는 큰 틀에서 작은 형식
	으로 변환됩니다.
	또한 int형과 double형으로 본 경우도 int형을 double형으로 변환하는 경우는 
	작은 형태로부터 큰 형태로 변환되고, 반대로 double형을 int형으로 변환하는 경우는
	큰 틀에서 작은 형식으로 변환된다.
	   기본 데이터형 중에서도 boolean형은 특별 boolean형에서 다른 데이터형식으로 변환
	할 수 없으며 반대로 boolean형으로 변환할 수 없습니다.
	주의할 점은 short형과 char형의 경우 또한 byte형과 char형의 경우이다.
	이 경우 어느 변화하는 경우도 큰 틀에서 작은 형식으로 변환하는 처리된다.
	크기가 큰 형식에서 작은 형식으로 변환하는 경우, 예를 들어 4자리 숫자밖에 들어가지 않는
	곳에 6자리를 넣으려고해도 들어가지 않도록 경우는 원래값을 그대로 저장할 수 없는 경우도 
	있다. 또한 작은 형태로부터 큰 형태로 변환하는 경우도 정수에서 부동소수점 숫자로 변환할
	때 원래값이 아닌 경우도 있다.
	*/	
	
	/*	크기가 작은 형에서 큰 형으로 변환
	  short에서 int형으로 변환이나 int형에서 long형으로 변환 등 크기가 작은형태로부터
	큰형태로 변환의 경우, 더 큰 숫자를 포함할 수 있는 곳으로 변환하는 것이기 때문에 자동적으로
	변환할 수 있습니다.
	  short s = 10;
	  int i = s;
	  long l = i;
	두번째 줄은 short형의 값을 int형의 변수에 할당하고 있습니다. 이때 short형의 값은 
	int형으로 변환된 후 할당되게 된다. 마찬가지로 세번째 줄은 int형의 값을 long형의 변수에
	할당하고 있다. 이때 int형의 값은 long형으로 변환된 후 할당되게 된다.
	이렇게 크기가 작은 형태로부터 큰 형태로 변환은 자동으로 변환을 수행하며 값 자체는 변함이 없다.
	short형의 10이라는 값은 int형으로 변환 되어도 int형의 10이 된다. 그러나 정수에서
	부동 소수점으로 변환할 때는 주의가 필요하다.
		long형에서 float 및 double로 변환할 때의 주의점
	예를 들어 float형태의 값은 음수값 -E38 ~ -E-45정도의 범위 양수는 E-45 ~ E+38의
	범위 값을 표현할 수 있다. 그러나 float 및 double은 자릿수가 있어서
	float형은 약 10진수 7자리(2진수에서 24자리),
	double형은 10진수로 약 16자리(2진수에서 53자리가)가 되고있다.
	자릿수는 표시된 수치에서 신뢰할수 있는 값이 무슨 자리 있는가 하는 것이며, 만약 자릿수가 3자리면
	12.345라는 숫자 신뢰할 수는 12.3 이후에 수치에는 오차가 포함되어있을 수 있다.
	또한 1.2345라는 수치가 나오면 신뢰할 수는 1.23까지로 그 이후의 수치는 오차가 포함되어있을
	수 있다.
	따라서 long값으로 7자리보다 큰 수치를 float형 값으로 변환하면 변환되지만 7자리 이하의 숫자
	는 오차가 포함될 수 있다. 마찬가지로 15자리 이상 큰 수치를 double형의 값으로 변환한 경우
	오차가 포함될 수 있다. 예를 보면,
	long l = 1234567890L;
	float f = l;
	이 경우 변환이 수행되지만 보정 전과 보정 후의 값을 화면에 출력하면 다른 결과가 나옵니다.
	*/
	/*	캐스트 변환	
	크기가 작은 형태로부터 큰 형태로 변환하는 경우, 대입하는 것만으로 자동으로 형식 변환이
	이뤄지고 있었지만 자료형을 명시적으로 하는 경우에는 캐스트 연산자를 사용한다. 형식은
	(데이터형)식
	변환하고자 하는 데이터유형을 ()사이에 기입하면 오른쪽에 적힌 식의 형식으로 변환할 수 있다.
	예를 들어 
	int i = 10;
	long l = (long) i;
	이 예에서는 int형 변수 i를 캐스팅 연산자를 사용해 long형으로 변환하고 있다. 이 경우 
	할당 이전 시점에서 이미 우변의 값은 long형으로 되어있다.
	이전 페이지에서 본대로 크기가 작은 형태로부터 큰 형태에 대입할 경우, 명시적으로 형변환
	연사자를 사용할 필요는 없지만, 반대로 크기가 큰 틀에서 작은 형태로 변환하는 등의 반드시
	캐스트 연산을 사용하여 데이터형식을 변환해야하는 경우도 있다.
	또한 식에서 연산의 우선 순위를 변경하는 경우에도 ()를 사용하지만, 괄호 안에 데이터형식인
	경우에는 캐스팅연산자다.	
	*/
		int i = 7;
		float f1 = (float) i/3;
		float f2 = (float) (i/3);
		System.out.println("f1 = " + f1);
		System.out.println("f2 = " + f2);
	/* 
	첫번째 계산식에서 변수 i를 float형으로 변환한 후 3으로 나눈 결과를 f1에 대입하고있다.
	두번째 계산식에서 변수 i를 3으로 나눈 결과를 float형으로 변환한 후 변수 f2에 대입하고있다.
	이러한 연산의 내용에 따라 결과가 다를 수 있다.
	*/
		
	/*	크기가 큰형에서 작은형으로 변환
	int형에서 short형으로 변환하거나 long을 int로 변환하는 등 크기가 큰 형식에서
	작은 형식으로 변환하면 캐스트 연산자를 사용하여 명시적으로 형태가 변경되는 것을 기입해야한다.
	잘못된 예다.
	int i = 10;
	short s = i;
	int형의 값을 short형의 값으로 단순히 대입했다.
	이 프로그램을 컴파일하면 "error.incompatible types: possible lossy 
	conversion from int to short"라는 컴파일 오류가 표시된다.
	이와 같이 크기가 큰 틀에서 작은 형태로 변환할 경우 캐스트 연산자는 필수이다. 따라서 다음과
	같이 기술할 필요가 있다.
	int i = 10;
	short s = (short) i;
	캐스트 연산자를 사용하면, 오류가 발생하지 않고 형식변환이 이뤄진다.
		숫자 리터럴을 지정한 경우의 특례
	단순히 정수를 작성하는 경우는 int형의 값으로 처리된다. 따라서 다음과 같이 기술하면 
	int형의 값을 캐스트하지 않고 short형의 변수에 할당하려고 할 것이다.
	short s = 10;
	이것은 크기가 큰 형식에서 작은 형식으로 변환되기 때문에 오류가 될 것이지만, 수치 자체를
	short형 또는 byte형에 대입하면 캐스팅을 하지않아도 오류가 발생하지 않는다.
	이 경우 자동으로 형식이 변환된다. 그러나 자동으로 형식이 변환되는 것은 short형 또는
	byte형의 범위에 있는 정수를 대입하는 경우만 해당된다.
	short s = 345321; 에러가 발생한다.
		변환에 따라서 수치 정보가 손실되는 경우
	큰 사이즈의 형태에서 작은 형식으로 변환하면 변환의 대상이 수치가 변환된 데이터형식을
	다룰 범위를 초과하면 올바른 숫자로 변환할 수 없다.
	int i = 10;
	short s = (short) i;
	이 경우 int형의 변수에 포함된 숫자 10은 변환된 short형으로도 처리할 수 있습니다.
	때문에 변환된 값도 10이 된다.
	int i = 345321;
	short s = (short) i;
	이 경우 int형의 변수에 저장된 숫자 345321은 변환된 short형으로 취급 범위를 초과
	하게 된다. 때문에 short형의 변수에 어떤 값이 저장되는지 모르게된다.
	또한 부동 소수점에서 정수로 변환하는 경우에는 정수가 소수점 이하의 값은 다루지 않으므로
	변환후에 잘리게 됩니다.
	double d = 12.345;
	int i = (int) d;
	이 경우 float형의 값을 int형 숫자로 변환하고 있지만, int는 정수밖에 취급하지 않기
	때문에 변환 전의 값 12.345 중 소수점 이하를 버리고 12가 int형 변수에 저장된다.
		byte/short/char형의 주의점
	"형식 변환의 기본 규칙"의 표를 보면 알겠지만 short형에서 char형식으로 변환, 반대로
	char형에서 short형으로 변환, 큰 사이즈의 작은 크기로 변환이 있다. short형과
	char형은 모두 16비트 데이터형식인데, 다룰 수 있는 범위가 다르다.
	char 	0~65535
	short	-32768~32767
	예를 들어 char형의 40000d이라는 수치를 short형으로 변환하면 정보가 손실될 수 있다.
	또한 short형 -300이라는 값을 char형으로 변환하면 정보가 손실될 수 있다. 또한 
	byte형에서 char형으로 변환하는 경우, byte형은 8비트이며 char형은 16비트인데
	byte형은 음수를 다룰 수에 char형은 양수 밖에 처리 할 수 없다.
	char 0~65535
	byte -128~128
	예를 들어 byte형 -17이란 수치를 char형으로 변환하면 정보가 손실될 수 있다.
	*/
	
	/*	연산할 때, 형식 변환의 규칙
	지금까지는 "="를 사용한 대입연산이 수행될 때, 형변환에 대해 봐왔다. 여기에 '+'나
	'*'등 2개의 값을 대상으로 한 이항 시 형변환 규칙에 대해 확인하겠다
	형식변환은 다음 규칙을 따른다.
	(1) 어느쪽 하나의 값을	double형의 경우 다른 값을	double형으로 변환하기
	(2) 어느쪽 하나의 값이	 float형의 경우 다른 값을       float형으로 변환하기
	(3) 어느쪽 하나의 값이	  long형의 경우 다른 값을	  long형으로 변환하기
	(4) (1)에서 (3)에 해당하지 않는 경우 두 값을 int형으로 변환
	이 규칙은 (1)부터 적용되며 이 중 하나에 적용되면 나중에 변환되지 않는다. 예를
	들어 double형과 long형의 값의 연산은 long형의 값을 double형으로 변환되어
	연산이 이뤄진다. 예를 보면
	double d = 12.345;
	long l = 3220L;
	double val = d*l;
	위에서의 double형 변수 "d"고 long형의 변수 "l"이 "*" 연산자로 연산될 때,
	먼저 long형의 변수 "l"이 double형으로 변환된 후에 연산을 수행한다.
	결과적으로 "d*l"은 double형으로 변환되어서 "="연산자는 좌변의 변수 "val"에
	대입된다. 또 다른 예를 보면
	int i = 83;
	double d = 12.345;
	long l = 3220L;
	double val = d + i*l;
	여러 연산자가 결합된 경우도 연산자의 우선 순위에 따라 순서대로 연산이 수행된다. 우선
	i*l이 이루어지지만 연산이 수행되기 전에 변수 i가 long형으로 변환된다. 결과적으로
	i*l은 long형의 값이다.
	다음으로 d와 i*l 연산이 수행되지만 연산이 수행되기 전에 i*l의 결과가 double형으로
	반환된다. 결과적으로 d + i * l 은 double형의 값이 된다.
		int형으로 변환에 따른 주의 사항
	double형,float형, long형에 해당하지 않는 모든 값은 int형으로 변환되고 나서
	연산이 이뤄진다. 즉, short형과 short형의 연산을 할 경우도 어느 쪽의 값도 일단
	int형으로 변환된 후 연산이 수행된다는 의미이다. 예를 보면
	short s1 = 10;
	short s2 = 9;
	short val = s1 + s2;
	보면 short형과 short형의 값을 연산한 결과를 short형의 변수에 대입하고 있기때문에
	문제 없는 것처럼 보이지만 컴파일하면, "정확도가 떨어지고 있는 가능성"이라는 컴파일
	오류가 나타난다. 이것은 연산자의 대상인 값도 double형, float형, long형에 
	해당하지 않으므로 연산이 수행되기 전에 두 값은 int형으로 변환되고 나서 연산이 이뤄진다.
	결과적으로 s1 + s2는 int형의 값입니다.
	int형의 값을 short형의 값에 대입하면 캐스트연산자가 필요하기 때문에 컴파일 오류가 
	발생한다. 정확하게 다음과 같이 기술할 필요가 있다.
	short s1 = 10;
	short s2 = 9;
	short val = (short)(s1 + s2);
		단항 연산자의 주의점
	단항 연산자를 사용하면 부호를 반전할 수 있다.
	int n1, n2;
	n1 = 10;
	n2 = -n1;
	그러나 byte형, short형, char형에서 단항 연산자를 사용할 때는 주의가 필요하다.
	byte형, short형, char형의 경우에는 부호를 반전시키기 전에 값을 int형으로
	자동으로 형을 변환하기 때문이다. 따라서 다음과 같이 기술하면 컴파일에서 "정확성이
	떨어지고 있는 가능성"이라는 컴파일 오류가 표시된다.
	short s1 = 10
	short s2 = -s1;
	이것은 단항 마이너스 연산자는 s1이 int형으로 변환되어 결과적으로 -s1이 int형의 값
	으로 되어있기 때문이다. int형의 값을 short형의 값에 대입하면 캐스트연산자가 필요
	하다. 정확하게 다음과 같이 기술할 필요가 있다.
	short s1 = 10;
	short s2 = (short)-s1;
	*/
	}
}
